---
title: "scATAC Tutorial"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## ArchR Setup
```{r install packages, eval = FALSE, include = FALSE}
if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
devtools::install_github("GreenleafLab/ArchR", ref="master", repos = BiocManager::repositories())
ArchR::installExtraPackages()
```


```{r install and load libraries, echo = F, message = F, warning = F}
library(ArchR)
set.seed(1)
```

```{r set threads, message = F, warning = F}
#set threads specific to your machine
addArchRThreads(threads = 35) 
```

We need a reference genome for downstream analyses. ArchR natively supports hg19, hg38, mm9, and mm10.
[Here is more information on how the genomes are compiled and how to create a custom genome](https://www.archrproject.com/bookdown/getting-set-up.html)

```{r download tutorial data and add genome}
inputFiles <- getTutorialData(tutorial = "Hematopoiesis")
inputFiles
addArchRGenome(genome = "hg19", install = FALSE)
```
### Creating Arrow Files

ArchR uses arrow files, the base unit of an ArchR analytical project. Every arrow file stores all the data associated with an individual sample (i.e. a single replicate of a particular condition). During creation and as additional analyses are performed, ArchR updates and edits each Arrow file to contain additional layers of information. An Arrow file is actually just a path to an external file stored on disk. More explicitly, an Arrow file is not an R-language object that is stored in memory but rather an HDF5-format file stored on disk. Input files can be i) scATAC tabix files, (ii) fragment files, or (iii) bam files.

[Here is the ArchR section on Arrow files](https://www.archrproject.com/bookdown/input-file-types-in-archr.html)
[Here is more information on Hierarchical Data Format (HDF)](https://en.wikipedia.org/wiki/Hierarchical_Data_Format)

```{r create arrowfiles, message = F, warning = F, cache = TRUE}
ArrowFiles <- createArrowFiles(
  inputFiles = inputFiles,
  sampleNames = names(inputFiles),
  minTSS = 4, #Dont set this too high because you can always increase later
  minFrags = 1000, 
  addTileMat = TRUE,
  addGeneScoreMat = TRUE
)
#We can inspect the ArrowFiles object to see that it is actually just a character vector of Arrow file paths.
ArrowFiles
```

### Per-cell Quality Control
Quality Control of scATAC-seq data is essential to remove cells that contribute to low-quality data. There are three characteristics that scATAC considers 
1. The number of unique nuclear fragments (i.e. not mapping to mitochondrial DNA).  
<br>
2. The signal-to-background ratio. Low signal-to-background ratio is often attributed to dead or dying cells which have de-chromatinzed DNA which allows for random transposition genome-wide. We expect high local enrichment at TSS regions relative to flanking regions +/- 2kb. Traditionally, the per-base-pair accessibility is computed for each bulk ATAC-seq sample and then this profile is used to determine the TSS enrichment score, a slow and computationally expensive approach if used for scATAC. To accurately approximate the TSS enrichment score per single cell, we count the average accessibility within a 50-bp region centered at each single-base TSS position and divide this by the average accessibility of the TSS flanking positions (+/- 1900 – 2000 bp). This approximation was highly correlated (R > 0.99) with the original method and values were extremely close in magnitude.  
<br>
3. The fragment size distribution. Due to nucleosomal periodicity, we expect to see depletion of fragments that are the length of DNA wrapped around a nucleosome (approximately 147 bp).  
<br>
These QC metrics are performed during ArrowFile generation.  
<br>
[More inforamtion on how each of these metrics are determined with ArchR](https://www.archrproject.com/bookdown/per-cell-quality-control.html)
<br>  

### ArchR doublet inference
ArchR also infers doublets, a single droplet that contains multiple cells. Determining and filtering out doublets are critical. Even 5% doublet rate exerts substantial effects on clustering. Doublets are effectively the average across two cells, and may appear as cell state/type intermediates.  
<br>
ArchR predicts doublets by synthesizing in-silico doublets, by merging reads from thousands of combinations of individual cells. These synthetic doublets are projected into the embedded UMAP and identify the nearest neighbor (real doublets). This process is iterated thousands of times to identify true doublets, "cells" whose signals looks very similar to the   By iterating this procedure thousands of times, ArchR identifies “cells” in our data whose signal looks very similar to synthetic doublets.  
<br>
[More details on how this approach was developed and validated](https://www.archrproject.com/bookdown/how-does-doublet-identification-work-in-archr.html)

```{r infer doublets, cache = TRUE}
doubScores <- addDoubletScores(
  input = ArrowFiles,
  k = 10, #Refers to how many cells near a "pseudo-doublet" to count.
  knnMethod = "UMAP", #Refers to the embedding/dimensionality reduction method to be used for k-nearest neighbor search.
  LSIMethod = 1
)
```
A good scATAC-seq library will have an R^2 >.9 R^2 values less than .9 indicates cells with little heterogeneity. This makes the accuracy of doublet calling worse because the majority of doublets would be “homotypic” - or a single droplet with two very similar cells.  
<br>

### Creating an ArchRProject
```{r Create ArchRProject, message = FALSE, cache = TRUE}
proj <- ArchRProject(
  ArrowFiles = ArrowFiles, 
  outputDirectory = "HemeTutorial",
  copyArrows = TRUE #This is recommended so that you maintain an unaltered copy for later usage.
)
```

There are many features to the ArchRProject that include manipulation, plotting sample statistics, fragments sizes, and TSS enrichment. A unique feature of ArchRProject is the ability to save and load the Project which allows for ease of sharing. [Check out more of these functions here](https://www.archrproject.com/bookdown/creating-an-archrproject.html)

```{r Filter ArchRProject, message = F, warning = F, cache = TRUE}
# We can query which data matrices are available in the ArchRProject. At this point in time, we should have “GeneScoreMatrix” and “TileMatrix”. As we continue to work and add to the ArchRProject, we can use the following function to query which matricies are added to the project.
getAvailableMatrices(proj)

# Next we can filter out putative doublets based on the scores established in the `infer doublets` chunk. Importantly, this does not delete the data from the Arrow files, but rather forces ArchRProject to ignore these cells. 
proj <- filterDoublets(ArchRProj = proj)
```

### Dimensionality Reduction and Clustering
<br>
Single cell genomics is a high dimensional data with approximately 20 000 dimensions corresponding to the protein coding gene. To visualize this data, dimensionality reduction techniques are used to visualize the data on UMAP or t-SNE. This is challenging with scATAC-seq because by nature, scATAC-seq is sparse (due to the binary nature of the data).  
<br>
[ArchR uses a standard Latent Semantic Indexing (LSI) approach.](https://www.archrproject.com/bookdown/dimensionality-reduction-with-archr.html) Briefly, LSI finds the most important region/peak for each sample. LSI reduces the dimensionality from thousands of uninformative  insertion counts to tens or hundreds informative, critical insertions.  
<br>
[Here is brief introduction to LSI](https://www.youtube.com/watch?v=Wd2iL7cJIv4&t=321s)
[Here is a more in depth view into LSI, SVD, and TF-IDF](https://www.youtube.com/watch?v=hB51kkus-Rc&t=1s)
[Here is more information on estimated LSI dimensionality reduction for large scATAC-seq datasets](https://www.archrproject.com/bookdown/estimated-lsi.html)
[If the LSI approach isnt sufficient for batch correction, read here for batch correction using Harmony](https://www.archrproject.com/bookdown/batch-effect-correction-wtih-harmony.html)
<br>
```{r Dimensionality Reduction, UMAP Generation and Visualization, message = F, warning = F, cache = TRUE}
# ArchR implements an iterative LSI dimensionality reduction via the addIterativeLSI() function.
proj <- addIterativeLSI(ArchRProj = proj, useMatrix = "TileMatrix", name = "IterativeLSI")

# To call clusters in this reduced dimension sub-space, we use the addClusters() function which uses Seurat’s graph clustering as the default clustering method.
proj <- addClusters(input = proj, reducedDims = "IterativeLSI")

# We can visualize our scATAC-seq data using a 2-dimensional representation such as Uniform Manifold Approximation and Projection (UMAP). To do this, we add a UMAP embedding to our ArchRProject object with the addUMAP() function. This function uses the uwot package to perform UMAP.
proj <- addUMAP(ArchRProj = proj, reducedDims = "IterativeLSI")
```
<br>
After identifying clusters in the LSI sub-space, ArchR embeddings such as UMAP and t-SNE can be used to visualie these clusters.
<br>
```{r UMAP Visualization}
# We can visualize the UMAP in a number of ways by calling various attributes of the cells stored in the `cellColData` matrix. Here, we can visualize the UMAP by sample, or clusters.
p1 <- plotEmbedding(ArchRProj = proj, colorBy = "cellColData", name = "Sample", embedding = "UMAP")
p2 <- plotEmbedding(ArchRProj = proj, colorBy = "cellColData", name = "Clusters", embedding = "UMAP")
ggAlignPlots(p1, p2, type = "h")
```

```{r Save UMAP embedding as PDF, message = FALSE}
#To save an editable vectorized version of this plot, we use the plotPDF() function.
plotPDF(p1,p2, name = "Plot-UMAP-Sample-Clusters.pdf",
        ArchRProj = proj, addDOC = FALSE, width = 5, height = 5)
```

### Gene Scores and Marker Genes with ArchR
<br>
#### [Assigning Clusters with Gene Scores](https://www.archrproject.com/bookdown/single-cell-embeddings.html)

The novelty of single cell approaches is to be able to resolve cellular heterogeneity in complex tissues. We can identify cells population by manually assigning cell-type specific markers to them. It is not possible to do this cell-type identification a priori.  
<br>
The manually annotation uses prior knowledge of cell type-specific marker genes and estimation of gene expression using gene scores. A gene score is a prediction of gene expression based on the accessibility of regulatory elements in the vicinity.  
<br>
[The gene score algorithm/model has three major components.](https://www.archrproject.com/bookdown/calculating-gene-scores-in-archr.html)
1. Accessibility within the entire gene body contributes to the gene score.
2. An exponential weighting function that accounts for the activity of putative distal regulatory elements in a distance-dependent fashion.
3. Imposed gene boundaries that minimizes the contribution of unrelated regulatory elements to the gene score.

First, we add imputation weights using [MAGIC](https://github.com/KrishnaswamyLab/MAGIC) to help smooth the dropout noise in our gene scores.

#### Cell cluster assignment a posteriori 
```{r Assign genes to clusters, message = FALSE, cache = TRUE}
proj <- addImputeWeights(proj)

#Now we can overlay our marker gene scores on our 2D UMAP embedding.
markerGenes  <- c(
    "CD34",  #Early Progenitor
    "GATA1", #Erythroid
    "PAX5", "MS4A1", "MME", #B-Cell Trajectory
    "CD14", "MPO", #Monocytes
    "CD3D", "CD8A"#TCells
  )
```

```{r Make plots, message = FALSE}
p <- plotEmbedding(
    ArchRProj = proj, 
    colorBy = "GeneScoreMatrix", 
    name = markerGenes, 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(proj)
)
```

```{r Plot UMAP Marker Genes}
#To plot a specific gene we can subset this plot list using the gene name.
p$CD14

#Plot all genes defined in markerGenes
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```
<br>
```{r, message=FALSE}
#Save an editable PDF version
plotPDF(plotList = p, 
    name = "Plot-UMAP-Marker-Genes-W-Imputation.pdf", 
    ArchRProj = proj, 
    addDOC = FALSE, width = 5, height = 5)
```
<br>

#### [Unbiased identification of marker features for cell clusters](https://www.archrproject.com/bookdown/identification-of-marker-features.html)
<br>
In addition to manual annotation of clusters, ArchR allows for unbiased identification of marker features (features being peaks, genes, or transcription factor motifs). This is done with the `getMarkerFeatures()` function with any matrix made up to this point (tiles, peaks, gene scores).

```{r Marker gene identification using gene scores}
# We'll begin by identifying marker genes using gene scores. Recall, gene scores were added when the ArchRProject was created in
markersGS <- getMarkerFeatures(
    ArchRProj = projHeme2, 
    useMatrix = "GeneScoreMatrix", 
    groupBy = "Clusters",
    bias = c("TSSEnrichment", "log10(nFrags)"),
    testMethod = "wilcoxon"
)
```
We can then make a list of marker genes with the desired cutoffs and list for each cluster
```{r Marker gene statistical and expression cutoff}
markerList <- getMarkers(markersGS, cutOff = "FDR <= 0.01 & Log2FC >= 1.25")
markerList$C6
```

We can visualize all marker genes across all clusters simultaneously. Additionally, we can manually annotate known marker genes.
```{r Visualize all marker genes}
markerGenes  <- c(
    "CD34", #Early Progenitor
    "GATA1", #Erythroid
    "PAX5", "MS4A1", "EBF1", "MME", #B-Cell Trajectory
    "CD14", "CEBPB", "MPO", #Monocytes
    "IRF8", 
    "CD3D", "CD8A", "TBX21", "IL7R" #TCells
  )

heatmapGS <- markerHeatmap(
  seMarker = markersGS, 
  cutOff = "FDR <= 0.01 & Log2FC >= 1.25", 
  labelMarkers = markerGenes,
  transpose = TRUE
)
```

```{r Save PDF of all marker genes}
plotPDF(heatmapGS, name = "GeneScores-Marker-Heatmap", width = 8, height = 6, ArchRProj = projHeme2, addDOC = FALSE)
```

### Visualizing Genome Browser Tracks

ArchR allows for visualization of genome browser tracks to browse local chromatin accessibility at marker genes on a per cluster basis. This is done by the following function `plotBrowserTrack()`.  

```{r Plot browser track of markerGenes within each cluster}
p <- plotBrowserTrack(
    ArchRProj = proj, 
    groupBy = "Clusters", 
    geneSymbol = markerGenes, 
    upstream = 50000,
    downstream = 50000
)
```
We can then select the gene marker we wish to visualize.  
```{r view local chromatin accessibility flanking CD14}
grid::grid.newpage()
grid::grid.draw(p$CD14)
```
Lastly, we save the above figure with the following.  
```{r save PDF of local chromatin accessibility flanking CD14}
plotPDF(plotList = p, 
    name = "Plot-Tracks-Marker-Genes.pdf", 
    ArchRProj = proj, 
    addDOC = FALSE, width = 5, height = 5)
```
### ArchR Shiny App

ArchR natively supports an interactice genome browser through shiny app that can be launched with the following.
```{r Load Shiny APp}
ArchRBrowser(ArchRProj = proj)
```
### Saving and Loading an ArchRProject
We can save the ArchRProject in session and load it at a later time. Saving copies the current ArchRProject object and all of the Arrow files to a specified directory (or the output directory specified earlier). Saving an ArchRProject allows us to easily load all computations we did in earlier steps, pr share the project with collaborators.  
<br>
Another way to leverage this save feature, we can run all the computational lines of code we did earlier on one Rmd, load the project on another Rmd to visualize the data. 
```{r Save ArchRProject}
proj <- saveArchRProject(ArchRProj = proj)
```
<br>
```{r Load ArchRProject}
proj <- loadArchRProject(path = "HemeTutorial")
```

### Defining Cluster Identity with scRNA-seq

ArchR allows for scATAC/scRNA-seq integration, performed using the `FindTransferAnchors()` function from the Seurat package. ArchR scales this procedure by dividing the cells in numerous groups and performing alignments in parallel.  
<br>
Ultimately, we can associate gene expression to predicted cis-regulatory elements.
```{r Download scRNA Hematopoiesis data}
if(!file.exists("scRNA-Hematopoiesis-Granja-2019.rds")){
    download.file(
        url = "https://jeffgranja.s3.amazonaws.com/ArchR/TestData/scRNA-Hematopoiesis-Granja-2019.rds",
        destfile = "scRNA-Hematopoiesis-Granja-2019.rds"
    )
}

seRNA <- readRDS("scRNA-Hematopoiesis-Granja-2019.rds")
seRNA
```

We can look at the metadata with the following line of code. Notice that BioClassification contains the cell type classification in the scRNA-seq dataset.
```{r seRNA metadata}
colnames(colData(seRNA))
```
and we can look at how many cells are in each cell-type.
```{r Number of cells in each cell-type}
table(colData(seRNA)$BioClassification)
```

#### Unconstrained Integration

The first round of integration we perform will be a preliminary unconstrained integration.

We will use we use the addGeneIntegrationMatrix() function. As mentioned above, this function accepts either a Seurat object or a RangedSummarizedExperiment object via the seRNA parameter.  (addToArrow = FALSE). We provide a name for the integration matrix that will be stored in the ArchRProject via the matrixName parameter. The other key parameters for this function provide column names in cellColData where certain information will be stored: nameCell will store the cell ID from the matched scRNA-seq cell, nameGroup will store the group ID from the scRNA-seq cell, and nameScore will store the cross-platform integration score.