---
title: "scATAC Tutorial"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## ArchR Setup
```{r install packages, eval = FALSE, include = FALSE}
if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
devtools::install_github("GreenleafLab/ArchR", ref="master", repos = BiocManager::repositories())
ArchR::installExtraPackages()
```


```{r install and load libraries, echo = F, message = F, warning = F}
library(ArchR)
set.seed(1)
```

```{r set threads, message = F, warning = F}
#set threads specific to your machine
addArchRThreads(threads = 35) 
```

We need a reference genome for downstream analyses. ArchR natively supports hg19, hg38, mm9, and mm10.
[Here is more information on how the genomes are compiled and how to create a custom genome](https://www.archrproject.com/bookdown/getting-set-up.html)

```{r download tutorial data and add genome}
inputFiles <- getTutorialData(tutorial = "Hematopoiesis")
inputFiles
addArchRGenome(genome = "hg19", install = FALSE)
```
### Creating Arrow Files

ArchR uses arrow files, the base unit of an ArchR analytical project. Every arrow file stores all the data associated with an individual sample (i.e. a single replicate of a particular condition). During creation and as additional analyses are performed, ArchR updates and edits each Arrow file to contain additional layers of information. An Arrow file is actually just a path to an external file stored on disk. More explicitly, an Arrow file is not an R-language object that is stored in memory but rather an HDF5-format file stored on disk. Input files can be i) scATAC tabix files, (ii) fragment files, or (iii) bam files.

[Here is the ArchR section on Arrow files](https://www.archrproject.com/bookdown/input-file-types-in-archr.html)
[Here is more information on Hierarchical Data Format (HDF)](https://en.wikipedia.org/wiki/Hierarchical_Data_Format)

```{r create arrowfiles, message = F, warning = F, cache = TRUE}
ArrowFiles <- createArrowFiles(
  inputFiles = inputFiles,
  sampleNames = names(inputFiles),
  minTSS = 4, #Dont set this too high because you can always increase later
  minFrags = 1000, 
  addTileMat = TRUE,
  addGeneScoreMat = TRUE
)
#We can inspect the ArrowFiles object to see that it is actually just a character vector of Arrow file paths.
ArrowFiles
```

### Per-cell Quality Control
Quality Control of scATAC-seq data is essential to remove cells that contribute to low-quality data. There are three characteristics that scATAC considers 
1. The number of unique nuclear fragments (i.e. not mapping to mitochondrial DNA).  
<br>
2. The signal-to-background ratio. Low signal-to-background ratio is often attributed to dead or dying cells which have de-chromatinzed DNA which allows for random transposition genome-wide. We expect high local enrichment at TSS regions relative to flanking regions +/- 2kb. Traditionally, the per-base-pair accessibility is computed for each bulk ATAC-seq sample and then this profile is used to determine the TSS enrichment score, a slow and computationally expensive approach if used for scATAC. To accurately approximate the TSS enrichment score per single cell, we count the average accessibility within a 50-bp region centered at each single-base TSS position and divide this by the average accessibility of the TSS flanking positions (+/- 1900 – 2000 bp). This approximation was highly correlated (R > 0.99) with the original method and values were extremely close in magnitude.  
<br>
3. The fragment size distribution. Due to nucleosomal periodicity, we expect to see depletion of fragments that are the length of DNA wrapped around a nucleosome (approximately 147 bp).  
<br>
These QC metrics are performed during ArrowFile generation.  
<br>
[More inforamtion on how each of these metrics are determined with ArchR](https://www.archrproject.com/bookdown/per-cell-quality-control.html)
<br>  

### ArchR doublet inference
ArchR also infers doublets, a single droplet that contains multiple cells. Determining and filtering out doublets are critical. Even 5% doublet rate exerts substantial effects on clustering. Doublets are effectively the average across two cells, and may appear as cell state/type intermediates.  
<br>
ArchR predicts doublets by synthesizing in-silico doublets, by merging reads from thousands of combinations of individual cells. These synthetic doublets are projected into the embedded UMAP and identify the nearest neighbor (real doublets). This process is iterated thousands of times to identify true doublets, "cells" whose signals looks very similar to the   By iterating this procedure thousands of times, ArchR identifies “cells” in our data whose signal looks very similar to synthetic doublets.  
<br>
[More details on how this approach was developed and validated](https://www.archrproject.com/bookdown/how-does-doublet-identification-work-in-archr.html)

```{r infer doublets, cache = TRUE}
doubScores <- addDoubletScores(
  input = ArrowFiles,
  k = 10, #Refers to how many cells near a "pseudo-doublet" to count.
  knnMethod = "UMAP", #Refers to the embedding/dimensionality reduction method to be used for k-nearest neighbor search.
  LSIMethod = 1
)
```
A good scATAC-seq library will have an R^2 >.9 R^2 values less than .9 indicates cells with little heterogeneity. This makes the accuracy of doublet calling worse because the majority of doublets would be “homotypic” - or a single droplet with two very similar cells.  
<br>

### Creating an ArchRProject
```{r Create ArchRProject, message = FALSE, cache = TRUE}
proj <- ArchRProject(
  ArrowFiles = ArrowFiles, 
  outputDirectory = "HemeTutorial",
  copyArrows = TRUE #This is recommended so that you maintain an unaltered copy for later usage.
)
```

There are many features to the ArchRProject that include manipulation, plotting sample statistics, fragments sizes, and TSS enrichment. A unique feature of ArchRProject is the ability to save and load the Project which allows for ease of sharing. [Check out more of these functions here](https://www.archrproject.com/bookdown/creating-an-archrproject.html)

```{r Filter ArchRProject, message = F, warning = F, cache = TRUE}
# We can query which data matrices are available in the ArchRProject. At this point in time, we should have “GeneScoreMatrix” and “TileMatrix”. As we continue to work and add to the ArchRProject, we can use the following function to query which matricies are added to the project.
getAvailableMatrices(proj)

# Next we can filter out putative doublets based on the scores established in the `infer doublets` chunk. Importantly, this does not delete the data from the Arrow files, but rather forces ArchRProject to ignore these cells. 
proj <- filterDoublets(ArchRProj = proj)
```

### Dimensionality Reduction and Clustering
<br>
Single cell genomics is a high dimensional data with approximately 20 000 dimensions corresponding to the protein coding gene. To visualize this data, dimensionality reduction techniques are used to visualize the data on UMAP or t-SNE. This is challenging with scATAC-seq because by nature, scATAC-seq is sparse (due to the binary nature of the data).  
<br>
[ArchR uses a standard Latent Semantic Indexing (LSI) approach.](https://www.archrproject.com/bookdown/dimensionality-reduction-with-archr.html) Briefly, LSI finds the most important region/peak for each sample. LSI reduces the dimensionality from thousands of uninformative  insertion counts to tens or hundreds informative, critical insertions.  
<br>
[Here is brief introduction to LSI](https://www.youtube.com/watch?v=Wd2iL7cJIv4&t=321s)
[Here is a more in depth view into LSI, SVD, and TF-IDF](https://www.youtube.com/watch?v=hB51kkus-Rc&t=1s)
[Here is more information on estimated LSI dimensionality reduction for large scATAC-seq datasets](https://www.archrproject.com/bookdown/estimated-lsi.html)
[If the LSI approach isnt sufficient for batch correction, read here for batch correction using Harmony](https://www.archrproject.com/bookdown/batch-effect-correction-wtih-harmony.html)
<br>
```{r Dimensionality Reduction, UMAP Generation and Visualization, message = F, warning = F, cache = TRUE}
# ArchR implements an iterative LSI dimensionality reduction via the addIterativeLSI() function.
proj <- addIterativeLSI(ArchRProj = proj, useMatrix = "TileMatrix", name = "IterativeLSI")

# To call clusters in this reduced dimension sub-space, we use the addClusters() function which uses Seurat’s graph clustering as the default clustering method.
proj <- addClusters(input = proj, reducedDims = "IterativeLSI")

# We can visualize our scATAC-seq data using a 2-dimensional representation such as Uniform Manifold Approximation and Projection (UMAP). To do this, we add a UMAP embedding to our ArchRProject object with the addUMAP() function. This function uses the uwot package to perform UMAP.
proj <- addUMAP(ArchRProj = proj, reducedDims = "IterativeLSI")
```
<br>
After identifying clusters in the LSI sub-space, ArchR embeddings such as UMAP and t-SNE can be used to visualie these clusters.
<br>
```{r UMAP Visualization}
# We can visualize the UMAP in a number of ways by calling various attributes of the cells stored in the `cellColData` matrix. Here, we can visualize the UMAP by sample, or clusters.
p1 <- plotEmbedding(ArchRProj = proj, colorBy = "cellColData", name = "Sample", embedding = "UMAP")
p2 <- plotEmbedding(ArchRProj = proj, colorBy = "cellColData", name = "Clusters", embedding = "UMAP")
ggAlignPlots(p1, p2, type = "h")
```

```{r Save UMAP embedding as PDF, message = FALSE}
#To save an editable vectorized version of this plot, we use the plotPDF() function.
plotPDF(p1,p2, name = "Plot-UMAP-Sample-Clusters.pdf",
        ArchRProj = proj, addDOC = FALSE, width = 5, height = 5)
```

### Gene Scores and Marker Genes with ArchR
<br>
#### [Assigning Clusters with Gene Scores](https://www.archrproject.com/bookdown/single-cell-embeddings.html)

The novelty of single cell approaches is to be able to resolve cellular heterogeneity in complex tissues. We can identify cells population by manually assigning cell-type specific markers to them. It is not possible to do this cell-type identification a priori.  
<br>
The manually annotation uses prior knowledge of cell type-specific marker genes and estimation of gene expression using gene scores. A gene score is a prediction of gene expression based on the accessibility of regulatory elements in the vicinity.  
<br>
[The gene score algorithm/model has three major components.](https://www.archrproject.com/bookdown/calculating-gene-scores-in-archr.html)
1. Accessibility within the entire gene body contributes to the gene score.
2. An exponential weighting function that accounts for the activity of putative distal regulatory elements in a distance-dependent fashion.
3. Imposed gene boundaries that minimizes the contribution of unrelated regulatory elements to the gene score.

First, we add imputation weights using [MAGIC](https://github.com/KrishnaswamyLab/MAGIC) to help smooth the dropout noise in our gene scores.

#### Cell cluster assignment a posteriori 
```{r Assign genes to clusters, message = FALSE, cache = TRUE}
proj <- addImputeWeights(proj)

#Now we can overlay our marker gene scores on our 2D UMAP embedding.
markerGenes  <- c(
    "CD34",  #Early Progenitor
    "GATA1", #Erythroid
    "PAX5", "MS4A1", "MME", #B-Cell Trajectory
    "CD14", "MPO", #Monocytes
    "CD3D", "CD8A"#TCells
  )
```

```{r Make plots, message = FALSE}
p <- plotEmbedding(
    ArchRProj = proj, 
    colorBy = "GeneScoreMatrix", 
    name = markerGenes, 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(proj)
)
```

```{r Plot UMAP Marker Genes}
#To plot a specific gene we can subset this plot list using the gene name.
p$CD14

#Plot all genes defined in markerGenes
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```
<br>
```{r, message=FALSE}
#Save an editable PDF version
plotPDF(plotList = p, 
    name = "Plot-UMAP-Marker-Genes-W-Imputation.pdf", 
    ArchRProj = proj, 
    addDOC = FALSE, width = 5, height = 5)
```
<br>

#### [Unbiased identification of marker features for cell clusters](https://www.archrproject.com/bookdown/identification-of-marker-features.html)
<br>
In addition to manual annotation of clusters, ArchR allows for unbiased identification of marker features (features being peaks, genes, or transcription factor motifs). This is done with the `getMarkerFeatures()` function with any matrix made up to this point (tiles, peaks, gene scores).

```{r Marker gene identification using gene scores}
# We'll begin by identifying marker genes using gene scores. Recall, gene scores were added when the ArchRProject was created in
markersGS <- getMarkerFeatures(
    ArchRProj = projHeme2, 
    useMatrix = "GeneScoreMatrix", 
    groupBy = "Clusters",
    bias = c("TSSEnrichment", "log10(nFrags)"),
    testMethod = "wilcoxon"
)
```
We can then make a list of marker genes with the desired cutoffs and list for each cluster
```{r Marker gene statistical and expression cutoff}
markerList <- getMarkers(markersGS, cutOff = "FDR <= 0.01 & Log2FC >= 1.25")
markerList$C6
```

We can visualize all marker genes across all clusters simultaneously. Additionally, we can manually annotate known marker genes.
```{r Visualize all marker genes}
markerGenes  <- c(
    "CD34", #Early Progenitor
    "GATA1", #Erythroid
    "PAX5", "MS4A1", "EBF1", "MME", #B-Cell Trajectory
    "CD14", "CEBPB", "MPO", #Monocytes
    "IRF8", 
    "CD3D", "CD8A", "TBX21", "IL7R" #TCells
  )

heatmapGS <- markerHeatmap(
  seMarker = markersGS, 
  cutOff = "FDR <= 0.01 & Log2FC >= 1.25", 
  labelMarkers = markerGenes,
  transpose = TRUE
)
```

```{r Save PDF of all marker genes}
plotPDF(heatmapGS, name = "GeneScores-Marker-Heatmap", width = 8, height = 6, ArchRProj = projHeme2, addDOC = FALSE)
```

### Visualizing Genome Browser Tracks

ArchR allows for visualization of genome browser tracks to browse local chromatin accessibility at marker genes on a per cluster basis. This is done by the following function `plotBrowserTrack()`.  

```{r Plot browser track of markerGenes within each cluster}
p <- plotBrowserTrack(
    ArchRProj = proj, 
    groupBy = "Clusters", 
    geneSymbol = markerGenes, 
    upstream = 50000,
    downstream = 50000
)
```
We can then select the gene marker we wish to visualize.  
```{r view local chromatin accessibility flanking CD14}
grid::grid.newpage()
grid::grid.draw(p$CD14)
```
Lastly, we save the above figure with the following.  
```{r save PDF of local chromatin accessibility flanking CD14}
plotPDF(plotList = p, 
    name = "Plot-Tracks-Marker-Genes.pdf", 
    ArchRProj = proj, 
    addDOC = FALSE, width = 5, height = 5)
```
### ArchR Shiny App

ArchR natively supports an interactice genome browser through shiny app that can be launched with the following.
```{r Load Shiny APp}
ArchRBrowser(ArchRProj = proj)
```
### Saving and Loading an ArchRProject
We can save the ArchRProject in session and load it at a later time. Saving copies the current ArchRProject object and all of the Arrow files to a specified directory (or the output directory specified earlier). Saving an ArchRProject allows us to easily load all computations we did in earlier steps, pr share the project with collaborators.  
<br>
Another way to leverage this save feature, we can run all the computational lines of code we did earlier on one Rmd, load the project on another Rmd to visualize the data. 
```{r Save ArchRProject}
proj <- saveArchRProject(ArchRProj = proj)
```
<br>
```{r Load ArchRProject}
proj <- loadArchRProject(path = "HemeTutorial")
```

### Defining Cluster Identity with scRNA-seq

ArchR allows for scATAC/scRNA-seq integration, performed using the `FindTransferAnchors()` function from the Seurat package. ArchR scales this procedure by dividing the cells in numerous groups and performing alignments in parallel.  
<br>
Ultimately, we can associate gene expression to predicted cis-regulatory elements.
```{r Download scRNA Hematopoiesis data}
if(!file.exists("scRNA-Hematopoiesis-Granja-2019.rds")){
    download.file(
        url = "https://jeffgranja.s3.amazonaws.com/ArchR/TestData/scRNA-Hematopoiesis-Granja-2019.rds",
        destfile = "scRNA-Hematopoiesis-Granja-2019.rds"
    )
}

seRNA <- readRDS("scRNA-Hematopoiesis-Granja-2019.rds")
seRNA
```

We can look at the metadata with the following line of code. Notice that BioClassification contains the cell type classification in the scRNA-seq dataset.
```{r seRNA metadata}
colnames(colData(seRNA))
```
and we can look at how many cells are in each cell-type.
```{r Number of cells in each cell-type}
table(colData(seRNA)$BioClassification)
```

#### Unconstrained Integration

The first round of integration we perform will be a preliminary unconstrained integration, in which we do not identify any scATAC-seq clusters. We will use we use the addGeneIntegrationMatrix() function with either a Seurat object or a RangedSummarizedExperiment object via the seRNA parameter. There are other parameters that provide column names.

*matrixName: Name for the integration matrix that will be stored in the ArchRProject 
*cellColData
  *nameCell: Cell ID from the matched scRNA-seq cell
  *nameGroup: Group ID from the scRNA-seq cell
  *nameScore: cross-platform integration score

```{r Unconstrained integration of scRNA/ATAC-seq}
projHeme2 <- addGeneIntegrationMatrix(
    ArchRProj = projHeme2, 
    useMatrix = "GeneScoreMatrix",
    matrixName = "GeneIntegrationMatrix",
    reducedDims = "IterativeLSI",
    seRNA = seRNA,
    addToArrow = FALSE,
    groupRNA = "BioClassification",
    nameCell = "predictedCell_Un",
    nameGroup = "predictedGroup_Un",
    nameScore = "predictedScore_Un"
)
```

#### Preparing constrained integration
We can then use the results of the unconstrained integration to further refine a constrained approach. In this tutorial, we want to identify which scRNA-seq cell types are most abundant in scATAC-seq clusters.  
<br> 
We will then identify T cells and NK cells from the unconstrained integration to refine our integrated approach.

```{r Creat confusion matrix}
cM <- as.matrix(confusionMatrix(projHeme2$Clusters, projHeme2$predictedGroup_Un))
preClust <- colnames(cM)[apply(cM, 1 , which.max)]
cbind(preClust, rownames(cM)) #Assignments
```
The above list shows which scRNA-seq cell type is most abundant in each of the 12 scATAC-seq clusters. There may be traces of other cell types within these clusters.  
<br>
Now we'll look at **all** scRNA-seq cell type labels were used in the unconstrained integration.  
```{r Identify cell type labels used in unconstrained integration}
unique(unique(projHeme2$predictedGroup_Un))
```
From the above list, we can see that the clusters in the scRNA-seq data that correspond to T cells and NK cells are Clusters 19-25. We will create a string-based representation of these clusters to use in the downstream constrained integration and call this cTNK
<br> 
We will also create a string-based representation of non TNK cells and call that variable cNonTNK.  
<br>
Now, we want to be able to pull all the cells of interest from their respective clusters. To do this, we will use the `grep()` function which will use a defined pattern to extract rows. The `|` acts as an OR statement as grep looks through the rows of our confusion matrix.
```{r create string of TNK and nonTNK identifiers}
#From scRNA
cTNK <- paste0(paste0(19:25), collapse="|")
cNonTNK <- paste0(c(paste0("0", 1:9), 10:13, 15:18), collapse="|")
cTNK
cNonTNK
```

```{r Identify scATAC-seq clusters that correspond to most abundant scRNA-seq cell types.}
#Assign scATAC to these categories
clustTNK <- rownames(cM)[grep(cTNK, preClust)]
clustTNK
clustNonTNK <- rownames(cM)[grep(cNonTNK, preClust)]
clustNonTNK
```
Using a similar approach, we will extract all cells that are TNK or Non TNK.
```{r Extract TNK and nonTNK scRNA-seq cells}
#RNA get cells in these categories
rnaTNK <- colnames(seRNA)[grep(cTNK, colData(seRNA)$BioClassification)]
head(rnaTNK)
rnaNonTNK <- colnames(seRNA)[grep(cNonTNK, colData(seRNA)$BioClassification)]
head(rnaNonTNK)
```

Now that we have all the scRNA/ATAC-seq cells, we'll create a nested list. This is a SimpleList within a SimpleList. We will have two groups: 1) T and NK within scATAC-seq and scRNA-seq and 2) non T and NK cells within scATAC-seq and scRNA-seq. Each of these SimpleList objects has two vectors of cell IDs, one called ATAC and one called RNA as shown below:
<br>
```{r Simplelist of objects we want to constrain}
groupList <- SimpleList(
    TNK = SimpleList(
        ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustTNK],
        RNA = rnaTNK
    ),
    NonTNK = SimpleList(
        ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustNonTNK],
        RNA = rnaNonTNK
    )    
)

# We pass this list to the `groupList` parameter of the `addGeneIntegrationMatrix()` function to constrain our integration. Note that, in this case, we are still not adding these results to the Arrow files (`addToArrow = FALSE`). We recommend checking the results of the integration thoroughly against your expectations prior to saving the results in the Arrow files. We illustrate this process in the next section of the book.
#~5 minutes
projHeme2 <- addGeneIntegrationMatrix(
    ArchRProj = projHeme2, 
    useMatrix = "GeneScoreMatrix",
    matrixName = "GeneIntegrationMatrix",
    reducedDims = "IterativeLSI",
    seRNA = seRNA,
    addToArrow = FALSE, 
    groupList = groupList,
    groupRNA = "BioClassification",
    nameCell = "predictedCell_Co",
    nameGroup = "predictedGroup_Co",
    nameScore = "predictedScore_Co"
)
```

#### Compare unconstrained and constrained integrations

```{r Create color palette}
# We will create a color palette using the ArchR built in package
pal <- paletteDiscrete(values = colData(seRNA)$BioClassification)
pal
```

```{r Visualize unconstrained and constrained integrations}
p1 <- plotEmbedding(
    projHeme2, 
    colorBy = "cellColData", 
    name = "predictedGroup_Un", 
    pal = pal
)
p2 <- plotEmbedding(
    projHeme2, 
    colorBy = "cellColData", 
    name = "predictedGroup_Co", 
    pal = pal
)
p1
p2
```

```{r Save PDF of Integrated UMAPs}
plotPDF(p1,p2, name = "Plot-UMAP-RNA-Integration.pdf", ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5)
```
Now we can save our ArchRProject with the updated ArrowFiles
```{r Save ArchRProjet}
saveArchRProject(ArchRProj = projHeme2, outputDirectory = "Save-ProjHeme2", load = FALSE)
```

#### Adding psuedo-scRNA-seq profiles for each scATAC-seq gene
```{r Add psuedo-scRNA-seq gene expression profiles}
#~5 minutes
projHeme3 <- addGeneIntegrationMatrix(
    ArchRProj = projHeme2, 
    useMatrix = "GeneScoreMatrix",
    matrixName = "GeneIntegrationMatrix",
    reducedDims = "IterativeLSI",
    seRNA = seRNA,
    addToArrow = TRUE,
    force= TRUE,
    groupList = groupList,
    groupRNA = "BioClassification",
    nameCell = "predictedCell",
    nameGroup = "predictedGroup",
    nameScore = "predictedScore"
)
```

GeneIntegrationMatrix should now be available to us
```{r Check projHeme3 matrices}
getAvailableMatrices(projHeme3)
```

We can compare the inferred gene expression obtained through gene scores, with the linked gene expression through integration. First we have to add magic imputations to our new project.

```{r Add impute weights to projHeme3}
projHeme3 <- addImputeWeights(projHeme3)
```

Now we'll make two separate UMAPs, one containing integrated gene expression (p1) and a second containing inferred gene expression (p2).

```{r Assign marker genes and make integrated UMAP gene expression}
markerGenes  <- c(
    "CD34", #Early Progenitor
    "GATA1", #Erythroid
    "PAX5", "MS4A1", #B-Cell Trajectory
    "CD14", #Monocytes
    "CD3D", "CD8A", "TBX21", "IL7R" #TCells
  )

p1 <- plotEmbedding(
    ArchRProj = projHeme3, 
    colorBy = "GeneIntegrationMatrix", 
    name = markerGenes, 
    continuousSet = "horizonExtra",
    embedding = "UMAP",
    imputeWeights = getImputeWeights(projHeme3)
)
```

```{r Make UMAP inferred gene of inferred gene expression}
p2 <- plotEmbedding(
    ArchRProj = projHeme3, 
    colorBy = "GeneScoreMatrix", 
    continuousSet = "horizonExtra",
    name = markerGenes, 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(projHeme3)
)
```

```{r Use ArchR homemade function for plots and plot integrated UMAP}
p1c <- lapply(p1, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})

p2c <- lapply(p2, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})

do.call(cowplot::plot_grid, c(list(ncol = 3), p1c))
```

```{r Plot inferred gene expression UMAP}
do.call(cowplot::plot_grid, c(list(ncol = 3), p2c))
```

```{r Save PDF of plot}
plotPDF(plotList = p1, 
    name = "Plot-UMAP-Marker-Genes-RNA-W-Imputation.pdf", 
    ArchRProj = projHeme3, 
    addDOC = FALSE, width = 5, height = 5)
```
#### Label scATAC-seq clusters with scRNA-seq information

First we'll make a confusionMatrix between scATAC-seq clusters and predicted groups from the integrated analysis.
```{r}
cM <- confusionMatrix(projHeme3$Clusters, projHeme3$predictedGroup)
labelOld <- rownames(cM)
labelOld
#  [1] "Cluster11" "Cluster2"  "Cluster12" "Cluster1"  "Cluster8"  "Cluster4" 
#  [7] "Cluster9"  "Cluster5"  "Cluster7"  "Cluster14" "Cluster3"  "Cluster10"
# [13] "Cluster6"  "Cluster13"
```
Identify the cell-type that best defines scATAC-seq cluster
```{r}
labelNew <- colnames(cM)[apply(cM, 1, which.max)]
labelNew
```
We'll now assign the colloquial names to all the possible clusters
```{r}
remapClust <- c(
    "01_HSC" = "Progenitor",
    "02_Early.Eryth" = "Erythroid",
    "03_Late.Eryth" = "Erythroid",
    "04_Early.Baso" = "Basophil",
    "05_CMP.LMPP" = "Progenitor",
    "06_CLP.1" = "CLP",
    "07_GMP" = "GMP",
    "08_GMP.Neut" = "GMP",
    "09_pDC" = "pDC",
    "10_cDC" = "cDC",
    "11_CD14.Mono.1" = "Mono",
    "12_CD14.Mono.2" = "Mono",
    "13_CD16.Mono" = "Mono",
    "15_CLP.2" = "CLP",
    "16_Pre.B" = "PreB",
    "17_B" = "B",
    "18_Plasma" = "Plasma",
    "19_CD8.N" = "CD8.N",
    "20_CD4.N1" = "CD4.N",
    "21_CD4.N2" = "CD4.N",
    "22_CD4.M" = "CD4.M",
    "23_CD8.EM" = "CD8.EM",
    "24_CD8.CM" = "CD8.CM",
    "25_NK" = "NK"
)
remapClust <- remapClust[names(remapClust) %in% labelNew]
```

We will map the new colloquial cluster names to the confusion matrix character vector. To do this, we will provide the colloquial and technical labels provided in `remapClust` to map onto `labelNew`.

```{r}
labelNew2 <- mapLabels(labelNew, oldLabels = names(remapClust), newLabels = remapClust)
labelNew2
#  [1] "GMP"        "B"          "PreB"       "CD4.N"      "Mono"      
#  [6] "Erythroid"  "Progenitor" "CD4.M"      "pDC"        "NK"        
# [11] "CLP"        "Mono"
```

We will now create a new column in projHeme3 that contains the new colloquial labels, and use that to label the UMAP 
```{r Use colloquial labels for UMAP}
projHeme3$Clusters2 <- mapLabels(projHeme3$Clusters, newLabels = labelNew2, oldLabels = labelOld)
p1 <- plotEmbedding(projHeme3, colorBy = "cellColData", name = "Clusters2")
p1
```

```{r Save PDF of colloquially labels UMAP clusters}
plotPDF(p1, name = "Plot-UMAP-Remap-Clusters.pdf", ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5)
```

```{r Save projHeme3}
saveArchRProject(ArchRProj = projHeme3, outputDirectory = "Save-ProjHeme3", load = FALSE)
```

### Creating psuedo-bulk replicates in ArchR

There are analyses that we cannot do with the single-cell data due to the nature of its sparcity. To overcome this, we can use ArchR to create psuedo-bulk replicates. This generates data that resembles a bulk ATAC-seq library.

We do this by grouping together single-cells derived from cell cluster or supersets of clusters. The ArchR process for making psuedo-bulk replicates is quite technical. [Read more here](https://www.archrproject.com/bookdown/pseudo-bulk-replicates-in-archr.html)

We will group cells from clusters, and we will used clusters defined by scRNA-seq integration in the last step. 
**NOTE: This grouping is not available if you did not integrate your across libraries. An alternative grouping will need to be used**
```{r Generate psuedo bulk libraries}
projHeme4 <- addGroupCoverages(ArchRProj = projHeme3, groupBy = "Clusters2")
```

### Calling bulk replicate peaks with ArchR

ArchR has their own proprietary, fixed widt, hpeak calling method. Other methods of peak calling include bedtools merge, bedtools cluster. They both have their own short comings that are resolved by the ArchR iterative overlap approach. You can also add in your own peak set. Read more [here](https://www.archrproject.com/bookdown/the-iterative-overlap-peak-merging-procedure.html)

ArchR looks for Macs2 for for peak calling. If it cannt find it, add it using the following code

```{r Path to Mac2}
pathToMacs2 <- findMacs2()
```

Now we can begin to generate a merged peak set with ArchR using `addReproduciblePeakSet()`. There are many other parameters we can play around with, so be sure to look through them with `~?addReproduciblePeakSet`.
**Note: We can only have one peak set per ArchRProject. If you would like to experiment with different peak sets, you must save a copy of your ArchRProject and thus also copy the Arrow files.**

#### Peak calling with Macs2

```{r}
projHeme4 <- addReproduciblePeakSet(
    ArchRProj = projHeme4, 
    groupBy = "Clusters2", 
    pathToMacs2 = pathToMacs2
)
```

We can retrieve these peaks as a GRanges object  with `getPeakSet()`. The peak set contains annotation for the group from which each peak originated. This does not mean the peak was only found in that group. Rather, the annotated group had the highest significance of that peak call.

```{r Retrieve peak annotations}
getPeakSet(projHeme4)
```

#### Peak calling with native ArchR approach, TileMatrix

We can call peaks with the native ArchR approach. ArchR recommends using Macs2 unless absolutely necessary. We will go through how to use this native ArchR peak caller, and how to compare the two approaches

To use the native peak caller, we set the paramter `method` to `p`.
```{r ArchR native peak caller}
projHemeTmp <- addReproduciblePeakSet(
    ArchRProj = projHeme4, 
    groupBy = "Clusters2",
    peakMethod = "Tiles",
    method = "p"
)
```

```{r Retrieve TileMatrix peaks}
getPeakSet(projHemeTmp)
```

#### Compare both peak calling approaches

We can compare the peak sets generated by both approaches by looking at the percent of overlapping peaks

First we'll look at MACS2-called peaks that are overlapped by the TileMatrix-called peaks
```{r MACS2-called peaks overlapped by TileMatrix-called peaks}
length(subsetByOverlaps(getPeakSet(projHeme4), getPeakSet(projHemeTmp))) / length(getPeakSet(projHeme4))
```

Then, we check the converse - the percent of TileMatrix-called peaks that are overlapped by MACS2-called peaks. You can see that this overlap is not as strong.
```{r TileMatrix-called peaks overlapped by MACS2-called peaks}
length(subsetByOverlaps(getPeakSet(projHemeTmp), getPeakSet(projHeme4))) / length(getPeakSet(projHemeTmp))
```

If we increase the margins of the peaks to be wider (1000-bp peaks instead of 500-bp peaks), the percent of MACS2-called peaks that are overlapped does not change much.
```{r MACS2-called peaks overlapped by TileMatrix-called peaks 1000-margin}
length(subsetByOverlaps(resize(getPeakSet(projHeme4), 1000, "center"), getPeakSet(projHemeTmp))) / length(getPeakSet(projHeme4))
```

But the percent of TileMatrix-called peaks overlapped by MACS2 does increase.
```{r TileMatrix-called peaks overlapped by MACS2-called peaks 1000-margin}
length(subsetByOverlaps(getPeakSet(projHemeTmp), resize(getPeakSet(projHeme4), 1000, "center"))) / length(getPeakSet(projHemeTmp))
```

We'll now save our ArchRProject with our preferred peak set, in this case MACS2 peaks.

```{r Save ArchRProject with peak calls}
saveArchRProject(ArchRProj = projHeme4, outputDirectory = "Save-ProjHeme4", load = FALSE)
```

We'll now prepare this data for downstream analyses.

```{r Create Project with peakMatrix}
projHeme5 <- addPeakMatrix(projHeme4)
```

Let's verify that `"PeakMatrix"` is available.

```{r Check available Matrices}
getAvailableMatrices(projHeme5)
```





